(ns sharpie.trapperkeeper.tracing
  "Interface to the OpenTracing API.

  The functions in this namespace allow Clojure to interact with the
  OpenTracing API."
  (:require
    [schema.core :as schema])
  (:import
    (io.opentracing Tracer)
    (io.opentracing.noop NoopTracerFactory)
    (io.opentracing.util GlobalTracer)))


(def ^:dynamic *tracer* (NoopTracerFactory/create))


(schema/defn set-tracer!
  "Set a new Tracer instance as the global tracer.

  This function updates the tracer instance referenced by the
  `io.opentracing.GlobalTracer` class along with the root of
  the `*tracer*` var.

  This function may be called exactly once. Multiple attempts
  to set the tracer will result in an error being raised."
  [tracer :- Tracer]
  ;; NOTE: GlobalTracer starts out with an instance of NoopTracer which
  ;;       can be replaced exactly once with a different Tracer instance.
  ;;       Attempting to register a second Tracer results in an error
  ;;       being raised.
  (GlobalTracer/register tracer)
  (alter-var-root #'*tracer* (constantly tracer)))

(defn build-span
  "Create a new span using the global tracer.

  The returned span is started but not passed to the scope
  manager for activation."
  ([span-name]
   (build-span span-name {}))
  ([span-name span-options]
   (-> *tracer*
       (.buildSpan span-name)
       .start)))

(defn activate-span!
  "Register a span with the global tracer as the active span.

  Returns a `io.opentracing.Scope` instance that responds to
  .close by finishing the span. Every activated scope should
  be closed, the `trace` macro sets up a try/finally block
  to ensure this."
  [span]
  (-> *tracer*
      .scopeManager
      (.activate span true)))

(defmacro trace
  "Execute an operation within the scope of an OpenTracing span.

  Constructs a span via a call to `build-span` and then executes the
  passed body within a try/finally block that ensures the span is
  finished. Returns the value generated by the last form in the body.

  IMPORTANT: Lazy operations can 'escape' this macro without having
  their time recorded if evaluation is deferred until after the trace
  scope closes. Plan accordingly."
  [options & body]
  (let [options (if (map? options)
                    options
                    {:id options})
        id (:id options)
        opts (dissoc options :id)]
    ;; NOTE: Consider providing a "fast track" that just evaluates to
    ;;       (do ~@body) if tracing is not enabled.
    `(let [span# (build-span ~id ~opts)
           scope# (activate-span! span#)]
       (try
         (do ~@body)
         ;; NOTE: Could also catch Exception here in order to flag the span
         ;;       as failed and log the error to span data. However, would
         ;;       need to figure out how to re-raise the exception without
         ;;       nested profiling stacks logging the same error at each
         ;;       level of the stack.
         (finally (.close scope#))))))
