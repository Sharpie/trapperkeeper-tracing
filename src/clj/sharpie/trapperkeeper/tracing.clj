(ns sharpie.trapperkeeper.tracing
  "Interface to the OpenTracing API.

  The functions in this namespace allow Clojure to interact with the
  OpenTracing API."
  (:require
    [schema.core :as schema])
  (:import
    (io.opentracing Tracer)
    (io.opentracing.noop NoopTracerFactory)
    (io.opentracing.util GlobalTracer)))


(def ^:dynamic *tracer* (NoopTracerFactory/create))


(schema/defn set-tracer!
  "Set a new Tracer instance as the global tracer.

  This function updates the tracer instance referenced by the
  `io.opentracing.GlobalTracer` class along with the root of
  the `*tracer*` var.

  This function may be called exactly once. Multiple attempts
  to set the tracer will result in an error being raised."
  [tracer :- Tracer]
  ;; NOTE: GlobalTracer starts out with an instance of NoopTracer which
  ;;       can be replaced exactly once with a different Tracer instance.
  ;;       Attempting to register a second Tracer results in an error
  ;;       being raised.
  (GlobalTracer/register tracer)
  (alter-var-root #'*tracer* (constantly tracer)))

(defn build-span
  "Create a new span using the global tracer.

  The `build-span` function takes a `span-name` which is a string that
  identifies the operation. Optionally, a map may be passed containing
  additional data that will be set on the span. Options that may be used:

    - :child-of An instance of io.opentracing.SpanContext or
                io.opentracing.Span to be set as the parent of the
                built span. If not passed, the currently active span
                from the scope manager will be used as the implicit
                parent. See `activate-span!`.

    - :tags     A map of tags that will be set on the span instance.
                Keys must be of type String. Values may be one of:
                String, Boolean, or Number.

  The returned span is started but not passed to the scope
  manager for activation."
  ([span-name]
   (build-span span-name {}))
  ([span-name span-options]
   (let [span (.buildSpan *tracer* span-name)]
     (when-let [parent (:child-of span-options)]
       (.asChildOf span parent))
     (when-let [tags (:tags span-options)]
       (doseq [[k v] tags]
         (.withTag span k v)))
     (.start span))))

(defn activate-span!
  "Register a span with the global tracer as the active span.

  Returns a `io.opentracing.Scope` instance that responds to
  .close by finishing the span. Every activated scope should
  be closed, the `trace` macro sets up a try/finally block
  to ensure this."
  [span]
  (-> *tracer*
      .scopeManager
      (.activate span true)))

(defmacro trace
  "Execute an operation within the scope of an OpenTracing span.

  Constructs a span via a call to `build-span` and then executes the
  passed body within a try/finally block that ensures the span is
  finished. Returns the value generated by the last form in the body.

  Argument may be either a string giving the operation name for the
  span or a map. If a map is used, the `:id` key must be set to the
  operation name and the remainder of the keys are used as options
  for the `build-span` function. This is done because multi-arity
  macros are weird and gross given the body is often an arbitrary
  sequence of forms.

  IMPORTANT: Lazy operations can 'escape' this macro without having
  their time recorded if evaluation is deferred until after the trace
  scope closes. Plan accordingly."
  [options & body]
  (let [options (if (map? options)
                    options
                    {:id options})
        id (:id options)
        opts (dissoc options :id)]
    ;; NOTE: Consider providing a "fast track" that just evaluates to
    ;;       (do ~@body) if tracing is not enabled.
    `(let [span# (build-span ~id ~opts)
           scope# (activate-span! span#)]
       (try
         (do ~@body)
         ;; NOTE: Could also catch Exception here in order to flag the span
         ;;       as failed and log the error to span data. However, would
         ;;       need to figure out how to re-raise the exception without
         ;;       nested profiling stacks logging the same error at each
         ;;       level of the stack.
         (finally (.close scope#))))))
